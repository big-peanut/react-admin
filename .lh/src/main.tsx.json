{
    "sourceFile": "src/main.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1741018305604,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1741018321532,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,18 +4,21 @@\n // It does not render any UI but activates additional checks and warnings.\r\n // This is particularly useful for catching issues with deprecated lifecycle methods and side effects.\r\n // It has no effect in production mode.\r\n import { StrictMode } from 'react'\r\n+\r\n //? Importing ReactDOM for rendering the app into the browser's DOM\r\n // ReactDOM is used to create and control the root of the React application.\r\n // The 'client' version of ReactDOM is imported because React 18 introduced concurrent rendering features.\r\n // This allows for improved rendering performance and responsiveness.\r\n import ReactDOM from 'react-dom/client'\r\n+\r\n //? Importing AxiosError for handling API errors in a structured way\r\n // AxiosError is a special error type provided by Axios, a popular HTTP client for making API requests.\r\n // This helps in identifying API-related errors separately from other types of errors.\r\n // By catching errors as AxiosError, we can inspect properties like response status and error messages.\r\n import { AxiosError } from 'axios'\r\n+\r\n //? Importing QueryCache, QueryClient, and QueryClientProvider from React Query\r\n // QueryClient manages all queries and mutations across the app, acting as a cache manager.\r\n // QueryCache handles how errors and cache updates are managed globally.\r\n // QueryClientProvider is the component that makes QueryClient available to the entire app.\r\n@@ -23,56 +26,64 @@\n   QueryCache,\r\n   QueryClient,\r\n   QueryClientProvider,\r\n } from '@tanstack/react-query'\r\n+\r\n //? Importing TanStack Router utilities for managing client-side routing\r\n // RouterProvider is responsible for rendering the correct route components based on the current URL.\r\n // createRouter is a function that creates a router instance, defining how routes are structured and managed.\r\n import { RouterProvider, createRouter } from '@tanstack/react-router'\r\n+\r\n //? Importing authentication store from a custom store using Zustand\r\n // This is a state management solution that keeps track of user authentication details.\r\n // The useAuthStore function allows us to get and update authentication state anywhere in the app.\r\n // This is useful for checking if a user is logged in and managing authentication-related actions like login/logout.\r\n import { useAuthStore } from '@/stores/authStore'\r\n+\r\n //? Importing a utility function to handle API errors\r\n // The handleServerError function is likely a custom utility that logs errors and provides user-friendly messages.\r\n // This ensures a consistent approach to handling and displaying server errors throughout the app.\r\n import { handleServerError } from '@/utils/handle-server-error'\r\n+\r\n //? Importing a custom hook for displaying toast notifications\r\n // Toast notifications are small messages that pop up to inform users about events (like errors or success messages).\r\n // This hook provides an easy way to trigger these notifications throughout the app.\r\n import { toast } from '@/hooks/use-toast'\r\n+\r\n //? Importing FontProvider to manage font settings across the app\r\n // FontProvider is a React context provider that likely manages different font styles and preferences.\r\n // This allows users to dynamically switch between different font types or sizes for accessibility.\r\n import { FontProvider } from './context/font-context'\r\n+\r\n //? Importing ThemeProvider to manage themes (light/dark mode)\r\n // This provider wraps the entire application, allowing components to access the theme state.\r\n // It likely provides functions to switch between dark and light themes based on user preferences.\r\n import { ThemeProvider } from './context/theme-context'\r\n+\r\n //? Importing the global stylesheet for the application\r\n // This CSS file contains styles that apply to the entire app, including resets, themes, and layouts.\r\n import './index.css'\r\n+\r\n //? Importing the generated route tree for the application\r\n // This file is auto-generated based on the application's defined routes.\r\n // It contains all available routes and their configurations, ensuring consistency in navigation.\r\n import { routeTree } from './routeTree.gen'\r\n \r\n /*\r\n- * Creating an instance of QueryClient to manage API calls and caching.\r\n- * QueryClient centralizes data fetching logic, caching, and background updates.\r\n- * It is highly efficient because it prevents unnecessary API calls by caching responses.\r\n- */\r\n+  * Creating an instance of QueryClient to manage API calls and caching.\r\n+  * QueryClient centralizes data fetching logic, caching, and background updates.\r\n+  * It is highly efficient because it prevents unnecessary API calls by caching responses.\r\n+*/\r\n const queryClient = new QueryClient({\r\n   defaultOptions: {\r\n     queries: {\r\n       /*\r\n-       * Defining how API queries should behave\r\n-       * The retry function determines whether a failed request should be retried.\r\n-       * - In development mode, errors are logged for debugging.\r\n-       * - In production, a failed request is retried up to 3 times before giving up.\r\n-       * - Requests with 401 (Unauthorized) or 403 (Forbidden) errors are never retried.\r\n-       */\r\n+        * Defining how API queries should behave\r\n+        * The retry function determines whether a failed request should be retried.\r\n+        * - In development mode, errors are logged for debugging.\r\n+        * - In production, a failed request is retried up to 3 times before giving up.\r\n+        * - Requests with 401 (Unauthorized) or 403 (Forbidden) errors are never retried.\r\n+      */\r\n       retry: (failureCount, error) => {\r\n         //? Log error details only in development mode for debugging purposes\r\n         if (import.meta.env.DEV) console.log({ failureCount, error })\r\n \r\n@@ -97,11 +108,11 @@\n     },\r\n \r\n     mutations: {\r\n       /*\r\n-       * Handling errors for mutations (POST, PUT, DELETE requests)\r\n-       * If an error occurs while modifying data, display an appropriate message.\r\n-       */\r\n+        * Handling errors for mutations (POST, PUT, DELETE requests)\r\n+        * If an error occurs while modifying data, display an appropriate message.\r\n+      */\r\n       onError: (error) => {\r\n         //? Call the global error handler to log and process the error\r\n         handleServerError(error)\r\n \r\n@@ -118,11 +129,11 @@\n     },\r\n   },\r\n \r\n   /*\r\n-   * Creating a QueryCache to manage error handling and caching of queries\r\n-   * The query cache is responsible for handling data synchronization across components.\r\n-   */\r\n+    * Creating a QueryCache to manage error handling and caching of queries\r\n+    * The query cache is responsible for handling data synchronization across components.\r\n+  */\r\n   queryCache: new QueryCache({\r\n     onError: (error) => {\r\n       if (error instanceof AxiosError) {\r\n         //? If the user session has expired, log them out and redirect to login page\r\n@@ -142,12 +153,12 @@\n   }),\r\n })\r\n \r\n /*\r\n- * Creating a new instance of the router with all available routes.\r\n- * The router is responsible for navigating between pages based on the URL.\r\n- * It integrates with React Query to provide seamless data fetching.\r\n- */\r\n+  * Creating a new instance of the router with all available routes.\r\n+  * The router is responsible for navigating between pages based on the URL.\r\n+  * It integrates with React Query to provide seamless data fetching.\r\n+*/\r\n const router = createRouter({\r\n   routeTree,\r\n   context: { queryClient },\r\n   defaultPreload: 'intent',\r\n"
                },
                {
                    "date": 1741018468253,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,18 +4,21 @@\n // It does not render any UI but activates additional checks and warnings.\r\n // This is particularly useful for catching issues with deprecated lifecycle methods and side effects.\r\n // It has no effect in production mode.\r\n import { StrictMode } from 'react'\r\n+\r\n //? Importing ReactDOM for rendering the app into the browser's DOM\r\n // ReactDOM is used to create and control the root of the React application.\r\n // The 'client' version of ReactDOM is imported because React 18 introduced concurrent rendering features.\r\n // This allows for improved rendering performance and responsiveness.\r\n import ReactDOM from 'react-dom/client'\r\n+\r\n //? Importing AxiosError for handling API errors in a structured way\r\n // AxiosError is a special error type provided by Axios, a popular HTTP client for making API requests.\r\n // This helps in identifying API-related errors separately from other types of errors.\r\n // By catching errors as AxiosError, we can inspect properties like response status and error messages.\r\n import { AxiosError } from 'axios'\r\n+\r\n //? Importing QueryCache, QueryClient, and QueryClientProvider from React Query\r\n // QueryClient manages all queries and mutations across the app, acting as a cache manager.\r\n // QueryCache handles how errors and cache updates are managed globally.\r\n // QueryClientProvider is the component that makes QueryClient available to the entire app.\r\n@@ -23,36 +26,44 @@\n   QueryCache,\r\n   QueryClient,\r\n   QueryClientProvider,\r\n } from '@tanstack/react-query'\r\n+\r\n //? Importing TanStack Router utilities for managing client-side routing\r\n // RouterProvider is responsible for rendering the correct route components based on the current URL.\r\n // createRouter is a function that creates a router instance, defining how routes are structured and managed.\r\n import { RouterProvider, createRouter } from '@tanstack/react-router'\r\n+\r\n //? Importing authentication store from a custom store using Zustand\r\n // This is a state management solution that keeps track of user authentication details.\r\n // The useAuthStore function allows us to get and update authentication state anywhere in the app.\r\n // This is useful for checking if a user is logged in and managing authentication-related actions like login/logout.\r\n import { useAuthStore } from '@/stores/authStore'\r\n+\r\n //? Importing a utility function to handle API errors\r\n // The handleServerError function is likely a custom utility that logs errors and provides user-friendly messages.\r\n // This ensures a consistent approach to handling and displaying server errors throughout the app.\r\n import { handleServerError } from '@/utils/handle-server-error'\r\n+\r\n //? Importing a custom hook for displaying toast notifications\r\n // Toast notifications are small messages that pop up to inform users about events (like errors or success messages).\r\n // This hook provides an easy way to trigger these notifications throughout the app.\r\n import { toast } from '@/hooks/use-toast'\r\n+\r\n //? Importing FontProvider to manage font settings across the app\r\n // FontProvider is a React context provider that likely manages different font styles and preferences.\r\n // This allows users to dynamically switch between different font types or sizes for accessibility.\r\n import { FontProvider } from './context/font-context'\r\n+\r\n //? Importing ThemeProvider to manage themes (light/dark mode)\r\n // This provider wraps the entire application, allowing components to access the theme state.\r\n // It likely provides functions to switch between dark and light themes based on user preferences.\r\n import { ThemeProvider } from './context/theme-context'\r\n+\r\n //? Importing the global stylesheet for the application\r\n // This CSS file contains styles that apply to the entire app, including resets, themes, and layouts.\r\n import './index.css'\r\n+\r\n //? Importing the generated route tree for the application\r\n // This file is auto-generated based on the application's defined routes.\r\n // It contains all available routes and their configurations, ensuring consistency in navigation.\r\n import { routeTree } from './routeTree.gen'\r\n@@ -178,5 +189,5 @@\n         </ThemeProvider>\r\n       </QueryClientProvider>\r\n     </StrictMode>\r\n   )\r\n-}\r\n+}\n\\ No newline at end of file\n"
                }
            ],
            "date": 1741018305604,
            "name": "Commit-0",
            "content": "//? Importing StrictMode from React\r\n// StrictMode is a special wrapper component provided by React.\r\n// It helps detect potential problems in an application during development.\r\n// It does not render any UI but activates additional checks and warnings.\r\n// This is particularly useful for catching issues with deprecated lifecycle methods and side effects.\r\n// It has no effect in production mode.\r\nimport { StrictMode } from 'react'\r\n\r\n//? Importing ReactDOM for rendering the app into the browser's DOM\r\n// ReactDOM is used to create and control the root of the React application.\r\n// The 'client' version of ReactDOM is imported because React 18 introduced concurrent rendering features.\r\n// This allows for improved rendering performance and responsiveness.\r\nimport ReactDOM from 'react-dom/client'\r\n\r\n//? Importing AxiosError for handling API errors in a structured way\r\n// AxiosError is a special error type provided by Axios, a popular HTTP client for making API requests.\r\n// This helps in identifying API-related errors separately from other types of errors.\r\n// By catching errors as AxiosError, we can inspect properties like response status and error messages.\r\nimport { AxiosError } from 'axios'\r\n\r\n//? Importing QueryCache, QueryClient, and QueryClientProvider from React Query\r\n// QueryClient manages all queries and mutations across the app, acting as a cache manager.\r\n// QueryCache handles how errors and cache updates are managed globally.\r\n// QueryClientProvider is the component that makes QueryClient available to the entire app.\r\nimport {\r\n  QueryCache,\r\n  QueryClient,\r\n  QueryClientProvider,\r\n} from '@tanstack/react-query'\r\n\r\n//? Importing TanStack Router utilities for managing client-side routing\r\n// RouterProvider is responsible for rendering the correct route components based on the current URL.\r\n// createRouter is a function that creates a router instance, defining how routes are structured and managed.\r\nimport { RouterProvider, createRouter } from '@tanstack/react-router'\r\n\r\n//? Importing authentication store from a custom store using Zustand\r\n// This is a state management solution that keeps track of user authentication details.\r\n// The useAuthStore function allows us to get and update authentication state anywhere in the app.\r\n// This is useful for checking if a user is logged in and managing authentication-related actions like login/logout.\r\nimport { useAuthStore } from '@/stores/authStore'\r\n\r\n//? Importing a utility function to handle API errors\r\n// The handleServerError function is likely a custom utility that logs errors and provides user-friendly messages.\r\n// This ensures a consistent approach to handling and displaying server errors throughout the app.\r\nimport { handleServerError } from '@/utils/handle-server-error'\r\n\r\n//? Importing a custom hook for displaying toast notifications\r\n// Toast notifications are small messages that pop up to inform users about events (like errors or success messages).\r\n// This hook provides an easy way to trigger these notifications throughout the app.\r\nimport { toast } from '@/hooks/use-toast'\r\n\r\n//? Importing FontProvider to manage font settings across the app\r\n// FontProvider is a React context provider that likely manages different font styles and preferences.\r\n// This allows users to dynamically switch between different font types or sizes for accessibility.\r\nimport { FontProvider } from './context/font-context'\r\n\r\n//? Importing ThemeProvider to manage themes (light/dark mode)\r\n// This provider wraps the entire application, allowing components to access the theme state.\r\n// It likely provides functions to switch between dark and light themes based on user preferences.\r\nimport { ThemeProvider } from './context/theme-context'\r\n\r\n//? Importing the global stylesheet for the application\r\n// This CSS file contains styles that apply to the entire app, including resets, themes, and layouts.\r\nimport './index.css'\r\n\r\n//? Importing the generated route tree for the application\r\n// This file is auto-generated based on the application's defined routes.\r\n// It contains all available routes and their configurations, ensuring consistency in navigation.\r\nimport { routeTree } from './routeTree.gen'\r\n\r\n/*\r\n  * Creating an instance of QueryClient to manage API calls and caching.\r\n  * QueryClient centralizes data fetching logic, caching, and background updates.\r\n  * It is highly efficient because it prevents unnecessary API calls by caching responses.\r\n*/\r\nconst queryClient = new QueryClient({\r\n  defaultOptions: {\r\n    queries: {\r\n      /*\r\n        * Defining how API queries should behave\r\n        * The retry function determines whether a failed request should be retried.\r\n        * - In development mode, errors are logged for debugging.\r\n        * - In production, a failed request is retried up to 3 times before giving up.\r\n        * - Requests with 401 (Unauthorized) or 403 (Forbidden) errors are never retried.\r\n      */\r\n      retry: (failureCount, error) => {\r\n        //? Log error details only in development mode for debugging purposes\r\n        if (import.meta.env.DEV) console.log({ failureCount, error })\r\n\r\n        //? In development mode, disable retries after any failure\r\n        if (failureCount >= 0 && import.meta.env.DEV) return false\r\n\r\n        //? In production, allow up to 3 retries before giving up\r\n        if (failureCount > 3 && import.meta.env.PROD) return false\r\n\r\n        //? Do not retry API requests if the error is related to authentication (401 or 403)\r\n        return !(\r\n          error instanceof AxiosError &&\r\n          [401, 403].includes(error.response?.status ?? 0)\r\n        )\r\n      },\r\n\r\n      //? Automatically refetch data when the window gains focus, but only in production\r\n      refetchOnWindowFocus: import.meta.env.PROD,\r\n\r\n      //? Data becomes \"stale\" after 10 seconds, meaning it will be refetched if needed\r\n      staleTime: 10 * 1000, // 10 seconds\r\n    },\r\n\r\n    mutations: {\r\n      /*\r\n        * Handling errors for mutations (POST, PUT, DELETE requests)\r\n        * If an error occurs while modifying data, display an appropriate message.\r\n      */\r\n      onError: (error) => {\r\n        //? Call the global error handler to log and process the error\r\n        handleServerError(error)\r\n\r\n        //? If the error is a 304 (Not Modified), show a toast notification\r\n        if (error instanceof AxiosError) {\r\n          if (error.response?.status === 304) {\r\n            toast({\r\n              variant: 'destructive',\r\n              title: 'Content not modified!',\r\n            })\r\n          }\r\n        }\r\n      },\r\n    },\r\n  },\r\n\r\n  /*\r\n    * Creating a QueryCache to manage error handling and caching of queries\r\n    * The query cache is responsible for handling data synchronization across components.\r\n  */\r\n  queryCache: new QueryCache({\r\n    onError: (error) => {\r\n      if (error instanceof AxiosError) {\r\n        //? If the user session has expired, log them out and redirect to login page\r\n        if (error.response?.status === 401) {\r\n          toast({ variant: 'destructive', title: 'Session expired!' })\r\n          useAuthStore.getState().auth.reset()\r\n          router.navigate({ to: '/sign-in' })\r\n        }\r\n\r\n        //? If the server encounters an internal error, show an error page\r\n        if (error.response?.status === 500) {\r\n          toast({ variant: 'destructive', title: 'Internal Server Error!' })\r\n          router.navigate({ to: '/500' })\r\n        }\r\n      }\r\n    },\r\n  }),\r\n})\r\n\r\n/*\r\n  * Creating a new instance of the router with all available routes.\r\n  * The router is responsible for navigating between pages based on the URL.\r\n  * It integrates with React Query to provide seamless data fetching.\r\n*/\r\nconst router = createRouter({\r\n  routeTree,\r\n  context: { queryClient },\r\n  defaultPreload: 'intent',\r\n  defaultPreloadStaleTime: 0,\r\n})\r\n\r\n//? Registering the router instance for TypeScript support\r\ndeclare module '@tanstack/react-router' {\r\n  interface Register {\r\n    router: typeof router\r\n  }\r\n}\r\n\r\n//? Getting the root element from the HTML file where the app will be mounted\r\nconst rootElement = document.getElementById('root')!\r\n\r\n//? Checking if the root element is empty before rendering the React app\r\nif (!rootElement.innerHTML) {\r\n  //? Creating a React root and rendering the application inside it\r\n  const root = ReactDOM.createRoot(rootElement)\r\n  root.render(\r\n    <StrictMode>\r\n      <QueryClientProvider client={queryClient}>\r\n        <ThemeProvider defaultTheme='light' storageKey='vite-ui-theme'>\r\n          <FontProvider>\r\n            <RouterProvider router={router} />\r\n          </FontProvider>\r\n        </ThemeProvider>\r\n      </QueryClientProvider>\r\n    </StrictMode>\r\n  )\r\n}\r\n"
        }
    ]
}